package tscfg

import java.io.PrintWriter
import java.util.Date

import tscfg.generator._
import tscfg.nodes._
import tscfg.nodes.implicits._
import tscfg.scalaUtil._

object scalaGenerator {

  def generate(node: Node, out: PrintWriter)
              (implicit genOpts: GenOpts): GenResult = {

    out.println(s"// generated by tscfg $version on ${new Date()}")
    genOpts.preamble foreach { p =>
      out.println(s"// ${p.replace("\n", "\n// ")}\n")
    }
    out.println(s"package ${genOpts.packageName}\n")

    var results = GenResult()

    gen(node)

    def gen(n: Node, indent: String = "")
           (implicit genOpts: GenOpts): Unit = {

      val simple = n.key.simple
      val symbol = if (simple == "/") genOpts.className else simple

      val scalaId = scalaIdentifier(symbol)

      n match {
        case ln: LeafNode  => genForLeaf(ln)
        case n: BranchNode => genForBranch(n)
      }

      def genForLeaf(ln: LeafNode): Unit = {
        out.println(s"$indent  $scalaId: ${ln.accessor.`type`}")
      }

      def genForBranch(bn: BranchNode): Unit = {
        var comma = ""

        val className = getClassName(symbol)

        val orderedNames = bn.keys().toList.sorted

        val padScalaIdLength = if (orderedNames.nonEmpty)
          orderedNames.map(scalaIdentifier).maxBy(_.length).length else 0
        def padScalaId(id: String) = id + (" " * (padScalaIdLength - id.length))

        // <object>
        out.println(s"${indent}object $className {")

        // <recurse>
        orderedNames foreach { name =>
          bn(name) match {
            case sbn@BranchNode(k, _) => gen(sbn, indent + "  ")
            case _ =>
          }
        }
        // </recurse>

        // <apply>
        // #13: add `build` auxiliary method to avoid type erasure issue in case of optional member
        out.println(s"$indent  def apply(c: com.typesafe.config.Config) = build(Some(c))")
        out.println(s"$indent  def apply() = build(None)")
        out.println(s"$indent  def build(c: scala.Option[${util.TypesafeConfigClassName}]): $className = {")
        out.println(s"$indent    $className(")

        comma = indent
        orderedNames foreach { name =>
          out.print(comma)
          bn(name) match {
            case ln@LeafNode(k, v) =>
              out.print(s"""      ${ln.accessor.instance(k.simple)}""")

            case BranchNode(k, _)  =>
              val className = getClassName(k.simple)
              out.print(s"""      $className.build(c.map(c => if (c.hasPath("${k.simple}")) Some(c.getConfig("${k.simple}")) else None).get)""")
          }
          comma = s",\n$indent"
        }
        out.println()
        out.println(s"$indent    )")
        out.println(s"$indent  }")
        // </apply>

        out.println(s"$indent}")
        // </object>

        // <class>
        results = results.copy(classNames = results.classNames + className)
        out.println(s"${indent}case class $className(")
        comma = ""
        orderedNames foreach { name =>
          val scalaId = scalaIdentifier(name)
          results = results.copy(fieldNames = results.fieldNames + scalaId)
          out.print(comma)
          out.print(s"$indent  ${padScalaId(scalaId)} : ")  // note, space before : for proper tokenization
          bn(name) match {
            case ln@LeafNode(k, v) =>
              out.print(s"""${ln.accessor.`type`}""")

            case BranchNode(k, _)  =>
              // use full qualified class name
              val className = genOpts.className + "." + k.parts.map(getClassName).mkString(".")
              out.print(s"""$className""")
          }
          comma = ",\n"
        }

        out.print(s"\n$indent)")

        if (genOpts.genToString || genOpts.genToPropString) {
          // <class-body>
          out.println(s" {")

          if (genOpts.genToString) {
            // toString():
            out.println(s"""$indent  override def toString: java.lang.String = toString("")""")

            val padNameLength = if (orderedNames.nonEmpty) orderedNames.maxBy(_.length).length else 0
            def padName(str: String) = str + (" " * (padNameLength - str.length))

            // <toString(i:java.lang.String)>
            out.println(s"""$indent  def toString(i:java.lang.String): java.lang.String = {""")
            val ids = orderedNames map { name =>
              val id = scalaIdentifier(name)

              bn(name) match {
                case ln@LeafNode(k, v) =>
                  s"""  i+ "${padName(name)} = """ +
                    (if (ln.accessor.`type` == "String") {
                      s"""" + '"' + this.$id + '"'"""
                    }
                    else if (ln.accessor.`type` == "Option[String]") {
                      val value = s"""if(this.$id.isDefined) "Some(" +'"' +this.$id.get+ '"' + ")" else "None""""
                      s"""" + (""" + value + ")"
                    }
                    else {
                      s"""" + this.$id"""
                    }) +
                    s""" + "\\n""""

                case BranchNode(k, _) =>
                  s"""  i+ "$name:\\n" + this.$id.toString(i+"    ")"""
              }
            }
            out.println(s"$indent  ${ids.mkString(s"+\n$indent  ")}")
            out.println(s"$indent  }")
            // <toString(i:java.lang.String)>
          }

          out.println(s"$indent}")
          // </class-body>
        }
        else out.println()
        // </class>
      }
    }
    results
  }
}
