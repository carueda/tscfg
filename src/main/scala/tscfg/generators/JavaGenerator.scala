package tscfg.generators

import java.util.Date

import tscfg.javaUtil._
import tscfg.generator._
import tscfg.specs._
import tscfg.specs.types._

import scala.annotation.tailrec

class JavaGenerator(implicit genOpts: GenOpts) extends Generator {

  def generate(objSpec: ObjSpec): GenResult = {

    var results = GenResult()

    def genObjSpec(name: String, objSpec: ObjSpec, indent: String, isRoot: Boolean = false): Code = {
      // <class>
      val className = getClassName(name)
      results = results.copy(classNames = results.classNames + className)

      val staticStr = if (isRoot) "" else " static"
      val code = Code(name, objSpec,
        javaType = className,
        javaId = javaIdentifier(name),
        declaration = indent + "public final " + className + " " + javaIdentifier(name) + ";"
      )

      code.println(indent + s"public$staticStr class $className {")

      // generate for members:
      val orderedNames = objSpec.children.keys.toList.sorted
      val codes = orderedNames map { name =>
        gen(name, objSpec.children(name), indent + IND)
      }

      // member declarations:
      codes.map(_.declaration).filter(_.nonEmpty).foreach(code.println)

      // member definitions:
      val definitions = codes.map(_.definition).filter(_.nonEmpty)
      if (definitions.nonEmpty) {
        code.println("")
        definitions.foreach(code.print)
      }

      // <constructor>
      code.println("")
      code.println(indent + IND + s"public $className($TypesafeConfigClassName c) {")
      codes foreach { memberCode ⇒
        code.println(
          indent + IND + IND + "this." + memberCode.javaId +
            " = " + instance(memberCode.spec, memberCode.name) + ";"
        )
      }
      code.println(indent + IND + "}")
      // </constructor>

      // auxiliary methods:
      accessors.insertAuxMethods(code, isRoot, indent + IND, results)

      code.println(indent + "}")
      // </class>

      code
    }

    def genAtomicSpec(name: String, spec: AtomicSpec, indent: String): Code = {
      val javaId = javaIdentifier(name)
      val javaType = getJavaType(spec, javaId)
      Code(name, spec,
        javaType,
        javaId = javaId,
        declaration = indent + "public final " + javaType + " " + javaId + ";")
    }

    def genListSpec(name: String, listSpec: ListSpec, indent: String): Code = {
      val elemName = getClassName(name+ "Element_")

      @tailrec
      def listNesting(ls: ListSpec, levels: Int): (Spec, Int) = ls.elemSpec match {
        case subListSpec: ListSpec ⇒ listNesting(subListSpec, levels + 1)
        case nonListSpec ⇒ (nonListSpec, levels)
      }

      val (elemSpec, levels) = listNesting(listSpec, 1)

      val elemCode = gen(elemName, elemSpec, indent)
      val elemObjType = toObjectType(elemCode.spec)
      val javaType = ("java.util.List<" * levels) + elemObjType + (">" * levels)
      val javaId = javaIdentifier(name)
      val code = Code(name, listSpec, javaType, javaId)

      if (elemCode.definition.nonEmpty) code.println(elemCode.definition)

      code.declaration = indent + "public final " + javaType + " " + javaId + ";"
      code
    }

    def gen(name: String, spec: Spec, indent: String = ""): Code = spec match {
      case spec: AtomicSpec    ⇒ genAtomicSpec(name, spec, indent)
      case spec: ObjSpec       ⇒ genObjSpec(name, spec, indent)
      case spec: ListSpec      ⇒ genListSpec(name, spec, indent)
    }

    val header = new StringBuilder()
    header.append(s"// generated by tscfg $version on ${new Date()}\n")
//    genOpts.preamble foreach { p =>
//      header.append(s"// ${p.replace("\n", "\n// ")}\n\n")
//    }
    header.append(s"package ${genOpts.packageName};\n\n")

    // main class:
    val elemSpec = genObjSpec(genOpts.className, objSpec, "", isRoot = true)

    results = results.copy(code = header.toString() + elemSpec.definition)

    results
  }

  case class Code(name: String,
                  spec: Spec,
                  javaType: String,
                  javaId: String,
                  var declaration: String = ""
                 ) {
    def println(str: String): Unit = defn.append(str).append('\n')

    def print(str: String): Unit = defn.append(str)

    def definition = defn.toString

    private val defn = new StringBuilder()
  }

  private val IND = "    "

  private def getJavaType(spec: Spec, javaId: String): String = {
    spec.typ match {
      case atomicType: AtomicType ⇒ atomicType match {
        case STRING   ⇒ "java.lang.String"
        case INTEGER  ⇒ if (spec.isOptional) "java.lang.Integer" else "int"
        case LONG     ⇒ if (spec.isOptional) "java.lang.Long"    else "long"
        case DOUBLE   ⇒ if (spec.isOptional) "java.lang.Double"  else "double"
        case BOOLEAN  ⇒ if (spec.isOptional) "java.lang.Boolean" else "boolean"
        case DURATION ⇒ if (spec.isOptional) "java.lang.Long"    else "long"
      }

      case ObjectType(name)  ⇒ getClassName(name)  // javaId

      case ListType(elemType)    ⇒
        val elemSpec = spec.asInstanceOf[ListSpec].elemSpec
        val elemJavaType = toObjectType(elemSpec)
        s"java.util.List<$elemJavaType>"
    }
  }

  private def toObjectType(spec: Spec): String = {
    toObjectType(spec.typ)
  }

  private def toObjectType(specType: SpecType): String = {
    specType match {
      case atomicType: AtomicType ⇒ atomicType match {
        case STRING   ⇒ "java.lang.String"
        case INTEGER  ⇒ "java.lang.Integer"
        case LONG     ⇒ "java.lang.Long"
        case DOUBLE   ⇒ "java.lang.Double"
        case BOOLEAN  ⇒ "java.lang.Boolean"
        case DURATION ⇒ "java.lang.Long"
      }
      case ObjectType(name)    ⇒ getClassName(name)
      case ListType(specType2)  ⇒ s"java.util.List<${toObjectType(specType2)}>"
    }
  }

  private def instance(spec: Spec, path: String): String = {
    spec.typ match {
      case atomicType: AtomicType ⇒ atomicType match {
        case STRING   ⇒
          if (spec.defaultValue.isDefined) {
            val value = spec.defaultValue.get
            s"""c != null && c.hasPath("$path") ? c.getString("$path") : "$value""""
          }
          else if (spec.isOptional) {
            s"""c != null && c.hasPath("$path") ? c.getString("$path") : null"""
          }
          else s"""c.getString("$path")"""

        case INTEGER  ⇒
          if (spec.defaultValue.isDefined) {
            val value = spec.defaultValue.get
            s"""c != null && c.hasPath("$path") ? c.getInt("$path") : $value"""
          }
          else if (spec.isOptional) {
            s"""c != null && c.hasPath("$path") ? c.getInt("$path") : null"""
          }
          else s"""c.getInt("$path")"""

        case LONG     ⇒
          if (spec.defaultValue.isDefined) {
            val value = spec.defaultValue.get
            s"""c != null && c.hasPath("$path") ? c.getLong("$path") : $value"""
          }
          else if (spec.isOptional) {
            s"""c != null && c.hasPath("$path") ? c.getLong("$path") : null"""
          }
          else s"""c.getLong("$path")"""

        case DOUBLE   ⇒
          if (spec.defaultValue.isDefined) {
            val value = spec.defaultValue.get
            s"""c != null && c.hasPath("$path") ? c.getDouble("$path") : $value"""
          }
          else if (spec.isOptional) {
            s"""c != null && c.hasPath("$path") ? c.getDouble("$path") : null"""
          }
          else s"""c.getDouble("$path")"""

        case BOOLEAN  ⇒
          if (spec.defaultValue.isDefined) {
            val value = spec.defaultValue.get
            s"""c != null && c.hasPath("$path") ? c.getBoolean("$path") : $value"""
          }
          else if (spec.isOptional) {
            s"""c != null && c.hasPath("$path") ? c.getBoolean("$path") : null"""
          }
          else s"""c.getBoolean("$path")"""


        case DURATION ⇒ s"""TODO_getDuration("$path")"""
      }

      case ObjectType(name)  ⇒
        s"""new ${getClassName(name)}(_$$config(c, "$path"))"""

      case ListType(specType)    ⇒
        val listSpec = spec.asInstanceOf[ListSpec]
        accessors._listName(listSpec.elemSpec) + s"""(c.getList("$path"))"""
    }
  }

  object accessors {
    // defined in terms of corresponding elemAccessor:
    type JavaElemTypeAndAccessor = (String,String)
    val definedListElemAccessors = collection.mutable.ListBuffer[JavaElemTypeAndAccessor]()

    def _listName(spec: Spec): String = {
      val typ = spec.typ
      val elemAccessor = typ match {
        case atomicType: AtomicType ⇒ atomicType match {
          case STRING   ⇒ "_$str"
          case INTEGER  ⇒ "_$int"
          case LONG     ⇒ "_$lng"
          case DOUBLE   ⇒ "_$dbl"
          case BOOLEAN  ⇒ "_$bol"
          case DURATION ⇒ "_$dur"
        }
        case ObjectType(name) ⇒
          "_" + name

        case ListType(specType) ⇒
          _listName(spec.asInstanceOf[ListSpec].elemSpec)
      }
      val javaType = toObjectType(spec)
      definedListElemAccessors += ((javaType, elemAccessor))
      "_$list" + elemAccessor
    }

    def _list(elemJavaType: String, elemAccessor: String): String = {
      val castCv = if (elemAccessor.startsWith("_$list")) "(com.typesafe.config.ConfigList)" else ""
      s"""
         |private static java.util.List<$elemJavaType> _$$list$elemAccessor(com.typesafe.config.ConfigList cl) {
         |  java.util.ArrayList<$elemJavaType> al = new java.util.ArrayList<$elemJavaType>();
         |  for (com.typesafe.config.ConfigValue cv: cl) {
         |    al.add($elemAccessor(${castCv}cv));
         |  }
         |  return java.util.Collections.unmodifiableList(al);
         |}""".stripMargin
    }

    def _int(): String = {
      """
        |private static java.lang.Integer _$int(com.typesafe.config.ConfigValue cv) {
        |  java.lang.Object u = cv.unwrapped();
        |  if (cv.valueType() != com.typesafe.config.ConfigValueType.NUMBER
        |      || !(u instanceof java.lang.Integer)) {
        |    _$exc(u, "integer");
        |  }
        |  return (java.lang.Integer) u;
        |}""".stripMargin
    }

    def _exc(): String = {
      """
        |private static void _$exc(java.lang.Object u, java.lang.String expected) {
        |  throw new java.lang.RuntimeException(
        |      "expecting: " +expected + " got: " +
        |          (u instanceof java.lang.String ? "\"" +u+ "\"" : u));
        |}""".stripMargin
    }

    val configGetter = s"""
      |private static $TypesafeConfigClassName _$$config($TypesafeConfigClassName c, java.lang.String path) {
      |  return c != null && c.hasPath(path) ? c.getConfig(path) : null;
      |}""".stripMargin

    def insertAuxMethods(code:Code, isRoot: Boolean, indent: String, results: GenResult): Unit = {
      definedListElemAccessors foreach { case (javaType, elemAccessor) ⇒
        println(s" --- $javaType  :  $elemAccessor")
        code.println(accessors._list(javaType, elemAccessor).replaceAll("\n", "\n" + indent))
      }
      code.println(accessors._int().replaceAll("\n", "\n" + indent))
      code.println(accessors._exc().replaceAll("\n", "\n" + indent))
      if (isRoot && results.classNames.size > 1) {
        code.println(accessors.configGetter.replaceAll("\n", "\n" + indent))
      }
    }
  }
}

object JavaGenerator {
  import java.io.File
  import com.typesafe.config.ConfigFactory
  import tscfg.SpecBuilder

  def main(args: Array[String]): Unit = {
    val filename = args(0)
    val file = new File(filename)
    val src = io.Source.fromFile(file).mkString.trim
    println("src:\n  |" + src.replaceAll("\n", "\n  |"))
    val config = ConfigFactory.parseString(src).resolve()

    val objSpec = SpecBuilder.fromConfig(config)
    println("\nobjSpec:\n  |" + objSpec.format().replaceAll("\n", "\n  |"))

    val className = "Java" + {
      val noPath = filename.substring(filename.lastIndexOf('/') + 1)
      val noDef = noPath.replaceAll("""^def\.""", "")
      val symbol = noDef.substring(0, noDef.indexOf('.'))
      symbol.charAt(0).toUpper + symbol.substring(1) + "Cfg"
    }
    implicit val genOpts = GenOpts("tscfg.example", className,
      preamble = Some(s"source: (a test)")
    )

    val generator: Generator = new JavaGenerator

    val results = generator.generate(objSpec)

    println("\n" + results.code)
  }
}
