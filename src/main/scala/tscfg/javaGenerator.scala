package tscfg

import java.io.PrintWriter
import java.util.Date

import tscfg.generator._
import tscfg.nodes._
import tscfg.nodes.implicits._
import tscfg.javaUtil._


object javaGenerator {

  def generate(node: Node, out: PrintWriter)
              (implicit genOpts: GenOpts): GenResult = {

    out.println(s"// generated by tscfg $version on ${new Date()}")
    genOpts.preamble foreach { p =>
      out.println(s"// ${p.replace("\n", "\n// ")}\n")
    }
    out.println(s"package ${genOpts.packageName};\n")

    var results = GenResult()

    gen(node)

    def gen(n: Node, indent: String = ""): Unit = {
      val simple = n.key.simple
      val isRoot = simple == "/"
      val symbol = if (simple == "/") genOpts.className else simple

      val javaId = javaIdentifier(symbol)

      n match {
        case ln: LeafNode  => genForLeaf(ln)
        case n: BranchNode => genForBranch(n)
      }

      def genForLeaf(ln: LeafNode): Unit = {
        out.println(s"${indent}public final ${ln.accessor.`type`} $javaId;")
      }

      def genForBranch(bn: BranchNode): Unit = {
        val className = getClassName(symbol)

        if (!isRoot) {
          // declare symbol:
          out.println(s"${indent}public final $className $javaId;")
        }

        // <class>
        results = results.copy(classNames = results.classNames + className)

        val classDecl = if (isRoot) "class" else "static class"
        out.println(s"${indent}public $classDecl $className {")

        val orderedNames = bn.keys().toList.sorted

        // generate for members:
        orderedNames foreach { name => gen(bn(name), indent + "  ") }

        // <constructor>
        out.println(s"$indent  public $className(${util.TypesafeConfigClassName} c) {")
        orderedNames foreach { name =>
          val javaId = javaIdentifier(name)
          results = results.copy(fieldNames = results.fieldNames + javaId)
          out.print(s"$indent    this.$javaId = ")
          bn(name) match {
            case ln@LeafNode(k, v) =>
              val path = k.simple
              val instance = ln.accessor.instance(path)
              out.println(s"""$instance;""")

            case BranchNode(k, _)  =>
              val className = getClassName(k.simple)
              out.println(s"""new $className(__$$config(c, "${k.simple}"));""")
          }
        }
        out.println(s"$indent  }")
        // </constructor>

        if (genOpts.genToString) {
          // toString():
          out.println(s"""$indent  public java.lang.String toString() { return toString(""); }""")

          // <toString(String i)>
          out.println(s"$indent  public java.lang.String toString(java.lang.String i) {")
          val ids = orderedNames map { name =>
            val id = javaIdentifier(name)

            bn(name) match {
              case ln@LeafNode(k, v) =>
                (if(ln.accessor.`type` == "String") {
                  if (ln.type_.required || ln.type_.value.isDefined)
                    s"""i+ "$id = " + '"' + this.$id + '"'"""
                  else
                    s"""i+ "$id = " + (this.$id == null ? null : '"' + this.$id + '"')"""
                }
                else {
                  s"""i+ "$id = " + this.$id"""
                }) + s""" + "\\n""""

              case BranchNode(k, _) =>
                s"""i+ "$id {\\n" + this.$id.toString(i+"    ") +i+ "}\\n""""
            }
          }
          out.println(s"$indent    return ${ids.mkString("\n" +indent + "        +")};")
          out.println(s"$indent  }")
          // </toString(String i)>
        }

        if (genOpts.genToPropString) {
          // toPropString():
          out.println(s"""$indent  public java.lang.String toPropString() { return toPropString(""); }""")

          // <toPropString(String p)>
          out.println(s"$indent  public java.lang.String toPropString(java.lang.String p) {")
          val ids3 = orderedNames map { name =>
            val id = javaIdentifier(name)

            bn(name) match {
              case ln@LeafNode(k, v) =>
                (if(ln.accessor.`type` == "String") {
                  if (ln.type_.required || ln.type_.value.isDefined)
                    s"""p+ "$id = " + '"' + this.$id + '"'"""
                  else
                    s"""p+ "$id = " + (this.$id == null ? null : '"' + this.$id + '"')"""
                }
                else {
                  s"""p+ "$id = " + this.$id"""
                }) + s""" + "\\n""""

              case BranchNode(k, _) =>
                s"""this.$id.toPropString(p+"$id.")"""
            }
          }
          out.println(s"$indent    return ${ids3.mkString("\n" +indent + "        +")};")
          out.println(s"$indent  }")
          // </toPropString(String p)>
        }

        if (isRoot && results.classNames.size > 1) {
          // declare symbol:
          val tscc = util.TypesafeConfigClassName
          out.println(s"$indent  private static $tscc __$$config($tscc c, java.lang.String path) {")
          out.println(s"$indent    return c != null && c.hasPath(path) ? c.getConfig(path) : null;")
          out.println(s"$indent  }")
        }

        out.println(s"$indent}")
        // </class>
      }
    }
    results
  }
}
